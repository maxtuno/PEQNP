{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The PEQNP System For more info visit www.peqnp.science . Introduction The PEQNP System its a automatic CNF encoder and SAT Solver for General Constrained Diophantine Equations. A simple example its the factorization of RSA numbers. With Integers: from peqnp import * rsa = 3007 engine(rsa.bit_length()) p = integer() q = integer() assert p * q == rsa while satisfy(): print(p, q) output: 3007 1 31 97 1 3007 97 31 Native Operations On PEQNP all elements are integers and relations on this integers, this relations are at bit level or arithmetic level. Supported Operations +, -, , /, *, %, &, |, ^, ==, =, <, <=, >, >=, <<, >>. Integers All integers live on \\mathbb{N}_{2^{bits} - 1} , all integers, are always positives, i.e. for two integer x, y the operation, x - y take all possibilities such that x - y >= 0 . The Mantra First is needed import all PEQNP system. from peqnp import * Define the data and constants. bits = 10 Next initialize the engine. engine(bits=10) Declare the variables. x = integer() Add constrains. assert x < 10 Solve the problem. while satisfy(): print(x)","title":"The PEQNP System"},{"location":"#the-peqnp-system","text":"For more info visit www.peqnp.science .","title":"The PEQNP System"},{"location":"#introduction","text":"The PEQNP System its a automatic CNF encoder and SAT Solver for General Constrained Diophantine Equations. A simple example its the factorization of RSA numbers.","title":"Introduction"},{"location":"#with-integers","text":"from peqnp import * rsa = 3007 engine(rsa.bit_length()) p = integer() q = integer() assert p * q == rsa while satisfy(): print(p, q) output: 3007 1 31 97 1 3007 97 31","title":"With Integers:"},{"location":"#native-operations","text":"On PEQNP all elements are integers and relations on this integers, this relations are at bit level or arithmetic level.","title":"Native Operations"},{"location":"#supported-operations","text":"+, -, , /, *, %, &, |, ^, ==, =, <, <=, >, >=, <<, >>.","title":"Supported Operations"},{"location":"#integers","text":"All integers live on \\mathbb{N}_{2^{bits} - 1} , all integers, are always positives, i.e. for two integer x, y the operation, x - y take all possibilities such that x - y >= 0 .","title":"Integers"},{"location":"#the-mantra","text":"First is needed import all PEQNP system. from peqnp import * Define the data and constants. bits = 10 Next initialize the engine. engine(bits=10) Declare the variables. x = integer() Add constrains. assert x < 10 Solve the problem. while satisfy(): print(x)","title":"The Mantra"},{"location":"diophantine/","text":"Diophantine Equations Let be x, y \\in \\mathbb{N} solve x^3 - x + 1 = y^2 from peqnp import * engine(10) x = integer() y = integer() assert x ** 3 - x + 1 == y ** 2 assert x != 0 assert y != 0 while satisfy(normalize=True): print('{0} ** 3 - {0} + 1, {1} ** 2'.format(x, y)) 5 ** 3 - 5 + 1, 11 ** 2 1 ** 3 - 1 + 1, 1 ** 2 3 ** 3 - 3 + 1, 5 ** 2 Let be x, y \\in \\mathbb{R} solve x^3 + xy = y^2 from peqnp import * engine(10) a = integer() b = integer() c = integer() d = integer() x = rational(a, b) y = rational(c, d) assert x ** 3 + x * y == y ** 2 assert a != 0 assert b != 0 assert c != 0 assert d != 0 while satisfy(normalize=True): print('({0} / {1}) ** 3 + ({0} / {1}) * ({2} / {3}), ({2} / {3}) ** 2'.format(a, b, c, d)) (6 / 1) ** 3 + (6 / 1) * (18 / 1), (18 / 1) ** 2 (2 / 1) ** 3 + (2 / 1) * (4 / 1), (4 / 1) ** 2 Let be x, y \\in \\mathbb{C} solve x^3 + x + 1 = y^2 from peqnp import * engine(10) a = integer() b = integer() c = integer() d = integer() x = gaussian(a, b) y = gaussian(c, d) assert x ** 3 + x + 1 == y ** 2 assert a != 0 assert b != 0 assert c != 0 assert d != 0 while satisfy(normalize=True): print('{0} ** 3 + {0} + 1, {1} ** 2'.format(complex(x), complex(y))) (2+1j) ** 3 + (2+1j) + 1, (3+2j) ** 2","title":"Diophantine Equations"},{"location":"diophantine/#diophantine-equations","text":"","title":"Diophantine Equations"},{"location":"diophantine/#let-be-x-y-in-mathbbn-solve-x3-x-1-y2","text":"from peqnp import * engine(10) x = integer() y = integer() assert x ** 3 - x + 1 == y ** 2 assert x != 0 assert y != 0 while satisfy(normalize=True): print('{0} ** 3 - {0} + 1, {1} ** 2'.format(x, y)) 5 ** 3 - 5 + 1, 11 ** 2 1 ** 3 - 1 + 1, 1 ** 2 3 ** 3 - 3 + 1, 5 ** 2","title":"Let be x, y \\in \\mathbb{N} solve x^3 - x + 1 = y^2"},{"location":"diophantine/#let-be-x-y-in-mathbbr-solve-x3-xy-y2","text":"from peqnp import * engine(10) a = integer() b = integer() c = integer() d = integer() x = rational(a, b) y = rational(c, d) assert x ** 3 + x * y == y ** 2 assert a != 0 assert b != 0 assert c != 0 assert d != 0 while satisfy(normalize=True): print('({0} / {1}) ** 3 + ({0} / {1}) * ({2} / {3}), ({2} / {3}) ** 2'.format(a, b, c, d)) (6 / 1) ** 3 + (6 / 1) * (18 / 1), (18 / 1) ** 2 (2 / 1) ** 3 + (2 / 1) * (4 / 1), (4 / 1) ** 2","title":"Let be x, y \\in \\mathbb{R} solve x^3 + xy = y^2"},{"location":"diophantine/#let-be-x-y-in-mathbbc-solve-x3-x-1-y2","text":"from peqnp import * engine(10) a = integer() b = integer() c = integer() d = integer() x = gaussian(a, b) y = gaussian(c, d) assert x ** 3 + x + 1 == y ** 2 assert a != 0 assert b != 0 assert c != 0 assert d != 0 while satisfy(normalize=True): print('{0} ** 3 + {0} + 1, {1} ** 2'.format(complex(x), complex(y))) (2+1j) ** 3 + (2+1j) + 1, (3+2j) ** 2","title":"Let be x, y \\in \\mathbb{C} solve x^3 + x + 1 = y^2"},{"location":"problems/","text":"NP-Complete Problems Satisfiability Study of boolean functions generally is concerned with the set of truth assignments (assignments of 0 or 1 to each of the variables) that make the function true. import functools import operator from peqnp import * n, m, cnf = 10, 24, [[9, -5, 10, -6, 3], [6, 8], [8, 4], [-10, 5], [-9, 8], [-9, -3], [-2, 5], [6, 4], [-2, -1], [7, -2], [-9, 4], [-1, -10], [-3, 4], [7, 5], [6, -3], [-10, 7], [-1, 7], [8, -3], [-2, -10], [-1, 5], [-7, 1, 9, -6, 3], [-9, 6], [-8, 10, -5, -4, 2], [-4, -7, 1, -8, 2]] # Initialize the engine with 2 bits engine(bits=2) # Declare an integer of n-bits, each ith-bits is one ith-literal on the model. x = integer(bits=n) # For each clause ensure that that one of the lierals are true. for cls in cnf: assert functools.reduce(operator.or_, (switch(x, abs(lit) - 1, neg=lit > 0) for lit in cls)) > 0 # Get only one solution or UNSAT. # The turbo parameter, say to SLIME4 SAT Solver, that make a full simplification, # then the internal structure of the problem is destroyed is more fast for one solution problems. if satisfy(turbo=True): print('SAT') print(' '.join(map(str, [(i + 1) if b else -(i + 1) for i, b in enumerate(x.binary)])) + ' 0') else: print('UNSAT') SAT -1 2 -3 4 5 -6 7 8 -9 -10 0 SLIME 4 SAT Solver from peqnp import * print(slime4('instance.cnf')) print(slime4('sat.cnf', 'sat.mod')) print(slime4('unsat.cnf', 'unsat.mod', 'unsat.proof')) 0-1 Integer Programming Input: Integer matrix C and integer vector d Property: There exist a 0-1 vector x sich that Cx=d . import numpy as np from peqnp import * # the dimensions of the matrix n, m = 10, 5 # The matrix cc = np.random.randint(0, 100, size=(n, m)) # Ensure that solution exist (for gen some interesting example) d = np.dot(cc, np.random.randint(0, 2, size=(m,))) print(cc) print(d) # Setup the engine with the bits of the sum of all values of the matrix, this ensure that the entire problem is well represented represented on the system. engine(bits=int(np.sum(cc)).bit_length()) # Declare a m-sized vector xs = vector(size=m) # All element of the vector are binaries, i.e. 0 or 1 all_binaries(xs) # The main constrain for the problem (there is a one of the Karp's 21 NP-complete problems https://people.eecs.berkeley.edu/~luca/cs172/karp.pdf) assert (np.dot(cc, xs) == d).all() # Get the first solution with turbo # very fast but destructive, this force a SLIME 4 SAT Solver do a full simplification, # only one solution is possible, because the internal structure of the problem is destroyed if satisfy(turbo=True): print(xs) print(np.dot(cc, xs)) else: print('Infeasible...') [[72 36 46 70 22] [57 35 37 99 60] [35 87 81 48 74] [12 33 8 73 89] [28 51 12 62 91] [71 65 69 87 2] [ 4 8 23 58 84] [93 88 71 50 78] [34 20 57 0 24] [83 95 37 61 50]] [108 92 122 45 79 136 12 181 54 178] [1, 1, 0, 0, 0] [108 92 122 45 79 136 12 181 54 178] Clique Input: Graph G , positive integer k Property: G has a set of mutually adjacent nodes. from peqnp import * # Ths size of the clique to search k = 3 # Get the graph and the dimension for the graph n, matrix = 5, [(1, 0), (0, 2), (1, 4), (2, 1), (4, 2), (3, 2)] # Ensure the problem can be represented engine(bits=k.bit_length()) # Declare an integer of n-bits bits = integer(bits=n) # The bits integer have \"size\"-active bits, i.e, the clique has \"size\"-elements assert sum(switch(bits, i) for i in range(n)) == k # This entangle all elements that are joined together for i in range(n - 1): for j in range(i + 1, n): if (i, j) not in matrix and (j, i) not in matrix: assert switch(bits, i) + switch(bits, j) <= 1 # Get the first solution with turbo # very fast but destructive, this force a SLIME 4 SAT Solver do a full simplification, # only one solution is possible, because the internal structure of the problem is destroyed if satisfy(turbo=True): print(k) print(' '.join([str(i) for i in range(n) if not bits.binary[i]])) else: print('Infeasible ...') 3 0 1 2 The Sum Subset Problem from peqnp import * # Get the target and data t, universe = 12, [2, 3, 5, 7, 11] # Declare an engine with same bits of the target. engine(bits=t.bit_length()) # Get all possible subsets for the data bits, subset = subsets(universe) # Ensure that this subset sum the target. assert sum(subset) == t # Solve if satisfy(turbo=True): solution = [universe[i] for i in range(len(universe)) if bits.binary[i]] print(sum(solution), solution) else: print('Infeasible ...') 12 [5, 7] Vertex Cover from peqnp import * # Get the graph and dimension, and the size of the cover. n, graph, vertex, k = 5, [(1, 0), (0, 2), (1, 4), (2, 1), (4, 2), (3, 2)], [0, 1, 2, 3, 4], 3 # Ensure the problem can be represented engine(bits=n.bit_length()) # An integer with n-bits to store the indexes for the cover index = integer(bits=n) # This entangled the all possible covers for i, j in graph: assert switch(index, vertex.index(i), neg=True) + switch(index, vertex.index(j), neg=True) >= 1 # Ensure the cover has size k assert sum(switch(index, vertex.index(i), neg=True) for i in vertex) == k # Get the first solution with turbo # very fast but destructive, this force a SLIME 4 SAT Solver do a full simplification, # only one solution is possible, because the internal structure of the problem is destroyed if satisfy(turbo=True): opt = sum(index.binary) print('p size {}'.format(opt)) print(' '.join([str(vertex[i]) for i in range(n) if index.binary[i]])) print() else: print('Infeasible ...') p size 3 1 2 4","title":"NP-Complete Problems"},{"location":"problems/#np-complete-problems","text":"","title":"NP-Complete Problems"},{"location":"problems/#satisfiability","text":"Study of boolean functions generally is concerned with the set of truth assignments (assignments of 0 or 1 to each of the variables) that make the function true. import functools import operator from peqnp import * n, m, cnf = 10, 24, [[9, -5, 10, -6, 3], [6, 8], [8, 4], [-10, 5], [-9, 8], [-9, -3], [-2, 5], [6, 4], [-2, -1], [7, -2], [-9, 4], [-1, -10], [-3, 4], [7, 5], [6, -3], [-10, 7], [-1, 7], [8, -3], [-2, -10], [-1, 5], [-7, 1, 9, -6, 3], [-9, 6], [-8, 10, -5, -4, 2], [-4, -7, 1, -8, 2]] # Initialize the engine with 2 bits engine(bits=2) # Declare an integer of n-bits, each ith-bits is one ith-literal on the model. x = integer(bits=n) # For each clause ensure that that one of the lierals are true. for cls in cnf: assert functools.reduce(operator.or_, (switch(x, abs(lit) - 1, neg=lit > 0) for lit in cls)) > 0 # Get only one solution or UNSAT. # The turbo parameter, say to SLIME4 SAT Solver, that make a full simplification, # then the internal structure of the problem is destroyed is more fast for one solution problems. if satisfy(turbo=True): print('SAT') print(' '.join(map(str, [(i + 1) if b else -(i + 1) for i, b in enumerate(x.binary)])) + ' 0') else: print('UNSAT') SAT -1 2 -3 4 5 -6 7 8 -9 -10 0","title":"Satisfiability"},{"location":"problems/#slime-4-sat-solver","text":"from peqnp import * print(slime4('instance.cnf')) print(slime4('sat.cnf', 'sat.mod')) print(slime4('unsat.cnf', 'unsat.mod', 'unsat.proof'))","title":"SLIME 4 SAT Solver"},{"location":"problems/#0-1-integer-programming","text":"Input: Integer matrix C and integer vector d Property: There exist a 0-1 vector x sich that Cx=d . import numpy as np from peqnp import * # the dimensions of the matrix n, m = 10, 5 # The matrix cc = np.random.randint(0, 100, size=(n, m)) # Ensure that solution exist (for gen some interesting example) d = np.dot(cc, np.random.randint(0, 2, size=(m,))) print(cc) print(d) # Setup the engine with the bits of the sum of all values of the matrix, this ensure that the entire problem is well represented represented on the system. engine(bits=int(np.sum(cc)).bit_length()) # Declare a m-sized vector xs = vector(size=m) # All element of the vector are binaries, i.e. 0 or 1 all_binaries(xs) # The main constrain for the problem (there is a one of the Karp's 21 NP-complete problems https://people.eecs.berkeley.edu/~luca/cs172/karp.pdf) assert (np.dot(cc, xs) == d).all() # Get the first solution with turbo # very fast but destructive, this force a SLIME 4 SAT Solver do a full simplification, # only one solution is possible, because the internal structure of the problem is destroyed if satisfy(turbo=True): print(xs) print(np.dot(cc, xs)) else: print('Infeasible...') [[72 36 46 70 22] [57 35 37 99 60] [35 87 81 48 74] [12 33 8 73 89] [28 51 12 62 91] [71 65 69 87 2] [ 4 8 23 58 84] [93 88 71 50 78] [34 20 57 0 24] [83 95 37 61 50]] [108 92 122 45 79 136 12 181 54 178] [1, 1, 0, 0, 0] [108 92 122 45 79 136 12 181 54 178]","title":"0-1 Integer Programming"},{"location":"problems/#clique","text":"Input: Graph G , positive integer k Property: G has a set of mutually adjacent nodes. from peqnp import * # Ths size of the clique to search k = 3 # Get the graph and the dimension for the graph n, matrix = 5, [(1, 0), (0, 2), (1, 4), (2, 1), (4, 2), (3, 2)] # Ensure the problem can be represented engine(bits=k.bit_length()) # Declare an integer of n-bits bits = integer(bits=n) # The bits integer have \"size\"-active bits, i.e, the clique has \"size\"-elements assert sum(switch(bits, i) for i in range(n)) == k # This entangle all elements that are joined together for i in range(n - 1): for j in range(i + 1, n): if (i, j) not in matrix and (j, i) not in matrix: assert switch(bits, i) + switch(bits, j) <= 1 # Get the first solution with turbo # very fast but destructive, this force a SLIME 4 SAT Solver do a full simplification, # only one solution is possible, because the internal structure of the problem is destroyed if satisfy(turbo=True): print(k) print(' '.join([str(i) for i in range(n) if not bits.binary[i]])) else: print('Infeasible ...') 3 0 1 2","title":"Clique"},{"location":"problems/#the-sum-subset-problem","text":"from peqnp import * # Get the target and data t, universe = 12, [2, 3, 5, 7, 11] # Declare an engine with same bits of the target. engine(bits=t.bit_length()) # Get all possible subsets for the data bits, subset = subsets(universe) # Ensure that this subset sum the target. assert sum(subset) == t # Solve if satisfy(turbo=True): solution = [universe[i] for i in range(len(universe)) if bits.binary[i]] print(sum(solution), solution) else: print('Infeasible ...') 12 [5, 7]","title":"The Sum Subset Problem"},{"location":"problems/#vertex-cover","text":"from peqnp import * # Get the graph and dimension, and the size of the cover. n, graph, vertex, k = 5, [(1, 0), (0, 2), (1, 4), (2, 1), (4, 2), (3, 2)], [0, 1, 2, 3, 4], 3 # Ensure the problem can be represented engine(bits=n.bit_length()) # An integer with n-bits to store the indexes for the cover index = integer(bits=n) # This entangled the all possible covers for i, j in graph: assert switch(index, vertex.index(i), neg=True) + switch(index, vertex.index(j), neg=True) >= 1 # Ensure the cover has size k assert sum(switch(index, vertex.index(i), neg=True) for i in vertex) == k # Get the first solution with turbo # very fast but destructive, this force a SLIME 4 SAT Solver do a full simplification, # only one solution is possible, because the internal structure of the problem is destroyed if satisfy(turbo=True): opt = sum(index.binary) print('p size {}'.format(opt)) print(' '.join([str(vertex[i]) for i in range(n) if index.binary[i]])) print() else: print('Infeasible ...') p size 3 1 2 4","title":"Vertex Cover"},{"location":"stdlib/","text":"The standard high level library def version(): \"\"\" Print the current version of the system. :return: \"\"\" def engine(bits=None, deepness=None): \"\"\" Initialize and reset the internal state of solver engine. :param bits: The size \\(2^{bits} - 1\\) of solving space. :param deepness: The scope for the exponential variables \\(bits / 4\\) by default. :return: \"\"\" def slime4(cnf_path, model_path='', proof_path=''): \"\"\" Use directly the SLIME 4 SAT Solver. :param cnf_path: The cnf file to solve. :param model_path: The path to the model if SAT, optional. :param proof_path: The path for the DRUP-PROOF if UNSAT, optional. :return: A List with the model if SAT else an empty list. \"\"\" def integer(key=None, bits=None): \"\"\" Correspond to an integer of name key, and size bits. :param key: The name of variable, appear on CNF when cnf_path is setting on satisfy(). :param bits: The bits size of the integer. :return: An instance of Integer. \"\"\" def constant(value=None, bits=None): \"\"\" Correspond to an constant of value with size bits. :param bits: The bits size of the constant. :param value: The value that represent the constant. :return: An instance of Constant. \"\"\" def satisfy(solve=True, turbo=False, log=False, assumptions=None, cnf_path='', model_path='', proof_path='', normalize=False): \"\"\" Find a model for the current problem. :param solve: This indicate if the instance can be solved or not, its use in conjunction with cnf_path. :param turbo: This make a simplification of the model, is more fast to solve, but destroy the internal structure of the problem, need regenerate, and gent only one solution. :param log: Shot the log for the SLIME SAT Solver. :param assumptions: A low level interrupt on the solver, this take a list with literals assumed true, and add to the hig level model. :param cnf_path: The path for the CNF representation of the problem, None by default and is not generated. :param model_path: The path for the MODEL of the problem, None by default and is not generated. :param proof_path: The path for the CNF DRUP-PROOF of the problem if this is unsatisfiable, None by default and is not generated. :param normalize: Indicate to the system that normalize integers from [2 ** (bits - 1), 2 ** bits - 1]. :return: True if SATISFIABLE else False \"\"\" def subsets(lst, k=None, key=None): \"\"\" Generate all subsets for an specific universe of data. :param lst: The universe of data. :param k: The cardinality of the subsets. :param key: The name os the binary representation of subsets. :return: (binary representation of subsets, the generic subset representation) \"\"\" def subset(data, k, empty=None): \"\"\" An operative structure (like integer ot constant) that represent a subset of at most k elements. :param data: The data for the subsets. :param k: The maximal size for subsets. :param empty: The empty element, 0, by default. :return: An instance of Subset. \"\"\" def vector(key=None, bits=None, size=None): \"\"\" A vector of integers. :param key: The generic name for the array this appear indexed on cnf. :param bits: The bit size for each integer. :param size: The size of the vector. :return: An instance of vector. \"\"\" def matrix(key=None, bits=None, dimensions=None): \"\"\" A matrix of integers. :param key: The generic name for the array this appear indexed on cnf. :param bits: The bit size for each integer. :param dimensions: An tuple with the dimensions for the array (n, m). :return: An instance of Matrix. \"\"\" def matrix_permutation(lst, n): \"\"\" This generate the permutations for an square matrix. :param lst: The flattened matrix of data, i.e. a vector. :param n: The dimension for the square nxn-matrix. :return: An tuple with (index for the elements, the elements that represent the indexes) \"\"\" def permutations(lst, n): \"\"\" Entangle all permutations of size n for the vector lst. :param lst: The list to entangle. :param n: The size of entanglement. :return: (indexes, values) \"\"\" def combinations(lst, n): \"\"\" Entangle all combinations of size n for the vector lst. :param lst: The list to entangle. :param n: The size of entanglement. :return: (indexes, values) \"\"\" def all_binaries(lst): \"\"\" This say that, the vector of integer are all binaries. :param lst: The vector of integers. :return: \"\"\" def switch(x, ith, neg=False): \"\"\" This conditionally flip the internal bit for an integer. :param x: The integer. :param ith: Indicate the ith bit. :param neg: indicate if the condition is inverted. :return: 0 if the uth bit for the argument collapse to true else return 1, if neg is active exchange 1 by 0. \"\"\" def one_of(lst): \"\"\" This indicate that at least one of the instruction on the array is active for the current problem. :param lst: A list of instructions. :return: The entangled structure. \"\"\" def factorial(x): \"\"\" The factorial for the integer. :param x: The integer. :return: The factorial. \"\"\" def sigma(f, i, n): \"\"\" The Sum for i to n, for the lambda f f, :param f: A lambda f with an standard int parameter. :param i: The start for the Sum, an standard int. :param n: The integer that represent the end of the Sum. :return: The entangled structure. \"\"\" def pi(f, i, n): \"\"\" The Pi for i to n, for the lambda f f, :param f: A lambda f with an standard int parameter. :param i: The start for the Pi, an standard int. :param n: The integer that represent the end of the Pi. :return: The entangled structure. \"\"\" def dot(xs, ys): \"\"\" The dot product of two compatible Vectors. :param xs: The fist vector. :param ys: The second vector. :return: The dot product. \"\"\" def mul(xs, ys): \"\"\" The elementwise product of two Vectors. :param xs: The fist vector. :param ys: The second vector. :return: The product. \"\"\" def apply_single(lst, f): \"\"\" A sequential operation over a vector. :param lst: The vector. :param f: The lambda f of one integer variable. :return: The entangled structure. \"\"\" def apply_dual(lst, f): \"\"\" A cross operation over a vector. :param lst: The vector. :param f: The lambda f of two integer variables. :return: The entangled structure. \"\"\" def all_different(args): \"\"\" The all different global constraint. :param args: A vector of integers. :return: \"\"\" def flatten(mtx): \"\"\" Flatten a matrix into list. :param mtx: The matrix. :return: The entangled structure. \"\"\" def bits(): \"\"\" The current bits for the engine. :return: The bits \"\"\" def oo(): \"\"\" The infinite for rhe system, the maximal value for the current engine. :return: 2 ** bits - 1 \"\"\" def element(item, data): \"\"\" Ensure that the element i is on the data, on the position index. :param item: The element :param data: The data :return: The position of element \"\"\" def index(ith, data): \"\"\" Ensure that the element i is on the data, on the position index. :param ith: The element :param data: The data :return: The position of element \"\"\" def gaussian(x, y): \"\"\" Create a gaussian integer from (x+yj). :param x: real :param y: imaginary :return: (x+yj) \"\"\" def rational(x, y): \"\"\" Create a rational x / y. :param x: numerator :param y: denominator :return: x / y \"\"\" def at_most_k(x, k): \"\"\" At most k bits can be activated for this integer. :param x: An integer. :param k: k elements :return: The encoded variable \"\"\" def sqrt(x): \"\"\" Define x as a perfect square. :param x: The integer :return: The square of this integer. \"\"\"","title":"The standard high level library"},{"location":"stdlib/#the-standard-high-level-library","text":"def version(): \"\"\" Print the current version of the system. :return: \"\"\" def engine(bits=None, deepness=None): \"\"\" Initialize and reset the internal state of solver engine. :param bits: The size \\(2^{bits} - 1\\) of solving space. :param deepness: The scope for the exponential variables \\(bits / 4\\) by default. :return: \"\"\" def slime4(cnf_path, model_path='', proof_path=''): \"\"\" Use directly the SLIME 4 SAT Solver. :param cnf_path: The cnf file to solve. :param model_path: The path to the model if SAT, optional. :param proof_path: The path for the DRUP-PROOF if UNSAT, optional. :return: A List with the model if SAT else an empty list. \"\"\" def integer(key=None, bits=None): \"\"\" Correspond to an integer of name key, and size bits. :param key: The name of variable, appear on CNF when cnf_path is setting on satisfy(). :param bits: The bits size of the integer. :return: An instance of Integer. \"\"\" def constant(value=None, bits=None): \"\"\" Correspond to an constant of value with size bits. :param bits: The bits size of the constant. :param value: The value that represent the constant. :return: An instance of Constant. \"\"\" def satisfy(solve=True, turbo=False, log=False, assumptions=None, cnf_path='', model_path='', proof_path='', normalize=False): \"\"\" Find a model for the current problem. :param solve: This indicate if the instance can be solved or not, its use in conjunction with cnf_path. :param turbo: This make a simplification of the model, is more fast to solve, but destroy the internal structure of the problem, need regenerate, and gent only one solution. :param log: Shot the log for the SLIME SAT Solver. :param assumptions: A low level interrupt on the solver, this take a list with literals assumed true, and add to the hig level model. :param cnf_path: The path for the CNF representation of the problem, None by default and is not generated. :param model_path: The path for the MODEL of the problem, None by default and is not generated. :param proof_path: The path for the CNF DRUP-PROOF of the problem if this is unsatisfiable, None by default and is not generated. :param normalize: Indicate to the system that normalize integers from [2 ** (bits - 1), 2 ** bits - 1]. :return: True if SATISFIABLE else False \"\"\" def subsets(lst, k=None, key=None): \"\"\" Generate all subsets for an specific universe of data. :param lst: The universe of data. :param k: The cardinality of the subsets. :param key: The name os the binary representation of subsets. :return: (binary representation of subsets, the generic subset representation) \"\"\" def subset(data, k, empty=None): \"\"\" An operative structure (like integer ot constant) that represent a subset of at most k elements. :param data: The data for the subsets. :param k: The maximal size for subsets. :param empty: The empty element, 0, by default. :return: An instance of Subset. \"\"\" def vector(key=None, bits=None, size=None): \"\"\" A vector of integers. :param key: The generic name for the array this appear indexed on cnf. :param bits: The bit size for each integer. :param size: The size of the vector. :return: An instance of vector. \"\"\" def matrix(key=None, bits=None, dimensions=None): \"\"\" A matrix of integers. :param key: The generic name for the array this appear indexed on cnf. :param bits: The bit size for each integer. :param dimensions: An tuple with the dimensions for the array (n, m). :return: An instance of Matrix. \"\"\" def matrix_permutation(lst, n): \"\"\" This generate the permutations for an square matrix. :param lst: The flattened matrix of data, i.e. a vector. :param n: The dimension for the square nxn-matrix. :return: An tuple with (index for the elements, the elements that represent the indexes) \"\"\" def permutations(lst, n): \"\"\" Entangle all permutations of size n for the vector lst. :param lst: The list to entangle. :param n: The size of entanglement. :return: (indexes, values) \"\"\" def combinations(lst, n): \"\"\" Entangle all combinations of size n for the vector lst. :param lst: The list to entangle. :param n: The size of entanglement. :return: (indexes, values) \"\"\" def all_binaries(lst): \"\"\" This say that, the vector of integer are all binaries. :param lst: The vector of integers. :return: \"\"\" def switch(x, ith, neg=False): \"\"\" This conditionally flip the internal bit for an integer. :param x: The integer. :param ith: Indicate the ith bit. :param neg: indicate if the condition is inverted. :return: 0 if the uth bit for the argument collapse to true else return 1, if neg is active exchange 1 by 0. \"\"\" def one_of(lst): \"\"\" This indicate that at least one of the instruction on the array is active for the current problem. :param lst: A list of instructions. :return: The entangled structure. \"\"\" def factorial(x): \"\"\" The factorial for the integer. :param x: The integer. :return: The factorial. \"\"\" def sigma(f, i, n): \"\"\" The Sum for i to n, for the lambda f f, :param f: A lambda f with an standard int parameter. :param i: The start for the Sum, an standard int. :param n: The integer that represent the end of the Sum. :return: The entangled structure. \"\"\" def pi(f, i, n): \"\"\" The Pi for i to n, for the lambda f f, :param f: A lambda f with an standard int parameter. :param i: The start for the Pi, an standard int. :param n: The integer that represent the end of the Pi. :return: The entangled structure. \"\"\" def dot(xs, ys): \"\"\" The dot product of two compatible Vectors. :param xs: The fist vector. :param ys: The second vector. :return: The dot product. \"\"\" def mul(xs, ys): \"\"\" The elementwise product of two Vectors. :param xs: The fist vector. :param ys: The second vector. :return: The product. \"\"\" def apply_single(lst, f): \"\"\" A sequential operation over a vector. :param lst: The vector. :param f: The lambda f of one integer variable. :return: The entangled structure. \"\"\" def apply_dual(lst, f): \"\"\" A cross operation over a vector. :param lst: The vector. :param f: The lambda f of two integer variables. :return: The entangled structure. \"\"\" def all_different(args): \"\"\" The all different global constraint. :param args: A vector of integers. :return: \"\"\" def flatten(mtx): \"\"\" Flatten a matrix into list. :param mtx: The matrix. :return: The entangled structure. \"\"\" def bits(): \"\"\" The current bits for the engine. :return: The bits \"\"\" def oo(): \"\"\" The infinite for rhe system, the maximal value for the current engine. :return: 2 ** bits - 1 \"\"\" def element(item, data): \"\"\" Ensure that the element i is on the data, on the position index. :param item: The element :param data: The data :return: The position of element \"\"\" def index(ith, data): \"\"\" Ensure that the element i is on the data, on the position index. :param ith: The element :param data: The data :return: The position of element \"\"\" def gaussian(x, y): \"\"\" Create a gaussian integer from (x+yj). :param x: real :param y: imaginary :return: (x+yj) \"\"\" def rational(x, y): \"\"\" Create a rational x / y. :param x: numerator :param y: denominator :return: x / y \"\"\" def at_most_k(x, k): \"\"\" At most k bits can be activated for this integer. :param x: An integer. :param k: k elements :return: The encoded variable \"\"\" def sqrt(x): \"\"\" Define x as a perfect square. :param x: The integer :return: The square of this integer. \"\"\"","title":"The standard high level library"}]}